"""Grandes Paradas API main module.

Provides FastAPI application with eight endpoints:
    * /calendar : retrieves UG maintenance periods from saved calendar
    * /calendar/maintenance : edits maintenance days in saved calendar with a json (ug, maintenance, old_days, new_days)
    * /health    : simple health check
    * /optimize : starts optimization in background and returns immediately
    * /optimize/parameters : gets/sets current optimization parameters (GET/PUT)
    * /optimize/status : gets the current status and progress of the optimization
    * /ug/{ug_number} : returns information for a specific UG
"""

import crud
from schemas import EditMaintenanceRequest, CalendarActivityResponse
from database import get_db, init_db
from fastapi import FastAPI, HTTPException, Depends, BackgroundTasks, Query
from sqlalchemy.ext.asyncio import AsyncSession
import time
import sys
import asyncio
import uuid
from pathlib import Path
from typing import Any, List, Dict, Optional
from collections import defaultdict
from optimize_module import Optimizer, constants


# Import database modules

app = FastAPI(title="Grandes Paradas API")

# In-memory storage for running optimizers per user
# Structure: {user: {"optimizer": Optimizer, "generator": generator, "latest_update": dict, "status": str, "run_id": str}}
# When a new optimization starts, the old one is completely removed from this dict
running_optimizers: Dict[str, Dict[str, Any]] = {}


@app.on_event("startup")
async def startup_event():
    """Initialize database on startup."""
    await init_db()
    # Initialize default user data
    async for db in get_db():
        try:
            await crud.initialize_default_user_data(db)
            await db.commit()
        finally:
            await db.close()


@app.get("/calendar")
async def get_calendar(
    user: str = Query(..., description="User identifier making the request"),
    db: AsyncSession = Depends(get_db)
) -> list[dict[str, Any]]:
    """Retrieve maintenance periods per generating unit (UG) from the saved calendar.

    The calendar must be generated by running the optimization process first via `/optimize`.

    Parameters
    ----------
    user : str
        User identifier making the request

    Returns
    -------
    list[dict[str, Any]]
        List of dictionaries; each dictionary aggregates one or more continuous
        maintenance periods for a UG under a specific maintenance code.

    Response schema (per item):
        - ``ug``: zero-padded string from "01" to "50"
        - ``maintenance``: string, one of the values defined in ``MAINTENANCE_CODES``
        - ``days``: list[int], days in 1..365 sorted ascending; may contain
          multiple continuous segments if more than one period was generated

    Raises
    ------
    HTTPException
        404 if no calendar is found. The user must run optimization first.
    """
    # Try to read active calendar from database (uses default if user doesn't have data)
    activities = await crud.get_calendar_activities(db, user)
    
    if not activities:
        raise HTTPException(
            status_code=404,
            detail="No calendar found. Please run the optimization process first via /optimize endpoint."
        )
    
    # Activities are already sorted in crud.get_calendar_activities
    return [activity.model_dump() for activity in activities]


@app.patch("/calendar/maintenance")
async def edit_maintenance(
    request: EditMaintenanceRequest,
    user: str = Query(..., description="User identifier making the request"),
    db: AsyncSession = Depends(get_db)
) -> dict[str, str]:
    """Edit days of a specific maintenance in the saved calendar.

    Parameters
    ----------
    request : EditMaintenanceRequest
        Edit data containing:
            • ``ug``: UG number (string format, e.g.: "01", "25")
            • ``maintenance``: maintenance code (e.g.: "AR", "CK")
            • ``old_days``: list of current days to be replaced
            • ``new_days``: list of new days
    user : str
        User identifier making the request

    Returns
    -------
    dict
        Dictionary with operation result:
            • ``status``: operation status
            • ``message``: descriptive message

    Raises
    ------
    HTTPException
        404 if there is no active calendar
        404 if UG or maintenance is not found
        400 if old days don't match saved ones
        500 if there is an error updating
    """
    try:
        # Ensure user has data (copy from default if needed)
        await crud.ensure_user_has_data(db, user)

        success = await crud.update_activity_days(
            db=db,
            user=user,
            ug=request.ug,
            maintenance=request.maintenance,
            old_days=request.old_days,
            new_days=request.new_days
        )

        if not success:
            # Check if calendar exists
            calendar = await crud.get_active_calendar(db, user)
            if not calendar:
                raise HTTPException(
                    status_code=404,
                    detail="No active calendar found. Generate a calendar first."
                )

            # Check if activity exists or if old days don't match
            from models import CalendarActivity
            from sqlalchemy import select

            result = await db.execute(
                select(CalendarActivity)
                .where(CalendarActivity.calendar_id == calendar.id)
                .where(CalendarActivity.ug == request.ug)
                .where(CalendarActivity.maintenance == request.maintenance)
            )
            activity = result.scalar_one_or_none()

            if not activity:
                raise HTTPException(
                    status_code=404,
                    detail=f"Maintenance '{request.maintenance}' for UG '{request.ug}' not found."
                )

            # Old days don't match
            current_days = set(activity.days)
            old_days_set = set(request.old_days)
            missing_days = old_days_set - current_days
            raise HTTPException(
                status_code=400,
                detail=f"Days {sorted(missing_days)} not found in current maintenance. "
                f"Current days: {sorted(current_days)}"
            )

        return {
            "status": "success",
            "message": f"Maintenance '{request.maintenance}' for UG '{request.ug}' edited successfully. "
                      f"Replaced {len(request.old_days)} days with {len(request.new_days)} new days."
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Error editing maintenance: {e}"
        )


@app.get("/health")
async def health(user: str = Query(..., description="User identifier making the request")) -> dict[str, str]:
    """Return a simple greeting.

    Acts as a health-check endpoint for the API.

    Parameters
    ----------
    user : str
        User identifier making the request
    """
    return {"message": "hello"}


def run_optimizer_sync(user: str, optm: Optimizer, run_id: str):
    """Run optimizer synchronously and update status (runs in thread pool)."""
    generator = optm.solve()
    running_optimizers[user] = {
        "optimizer": optm,
        "generator": generator,
        "latest_update": None,
        "status": "running",
        "run_id": run_id
    }

    try:
        final_update = None
        for update in generator:
            # Check if this optimization was replaced by a new one
            current_state = running_optimizers.get(user, {})
            if current_state.get("run_id") != run_id:
                # This run was replaced, stop processing
                break

            current_state["latest_update"] = update
            if update["status"] == "completed":
                final_update = update
                current_state["status"] = "completed"
                break

        # Only save activities if this is still the current run
        current_state = running_optimizers.get(user, {})
        if final_update and "schedule" in final_update and current_state.get("run_id") == run_id:
            # Convert schedule format from optimizer to database format
            # Optimizer returns: ug as int (1-50), days as 0-indexed (0-364)
            # Database expects: ug as zero-padded string ("01"-"50"), days as 1-indexed (1-365)
            activities = []
            for activity in final_update["schedule"]:
                activities.append({
                    # Convert int to zero-padded string
                    "ug": f"{activity['ug']:02d}",
                    "maintenance": activity["maintenance"],
                    # Convert 0-indexed to 1-indexed
                    "days": [day + 1 for day in activity["days"]]
                })

            # Store activities for async database save
            current_state["activities"] = activities
    except Exception as e:
        # Only set error if this is still the current run
        current_state = running_optimizers.get(user, {})
        if current_state.get("run_id") == run_id:
            current_state["status"] = "error"
            current_state["error"] = str(e)


async def save_optimizer_result(user: str):
    """Save optimizer result to database asynchronously."""
    if user not in running_optimizers:
        return

    optimizer_state = running_optimizers[user]
    if "activities" not in optimizer_state:
        return

    activities = optimizer_state["activities"]

    # Create a new database session for the background task
    from database import AsyncSessionLocal
    async with AsyncSessionLocal() as db:
        try:
            # Ensure user has data (copy from default if needed)
            await crud.ensure_user_has_data(db, user)
            await crud.create_calendar(db=db, activities=activities, user=user)
            await db.commit()
            # Remove activities from state after successful save
            del running_optimizers[user]["activities"]
        except Exception as db_error:
            await db.rollback()
            running_optimizers[user]["status"] = "error"
            running_optimizers[user]["error"] = f"Database error: {str(db_error)}"


async def run_optimizer_background(user: str, optm: Optimizer, run_id: str):
    """Run optimizer in background and update status."""
    # Run the synchronous optimizer in a thread pool
    loop = asyncio.get_event_loop()
    await loop.run_in_executor(None, run_optimizer_sync, user, optm, run_id)

    # Save result to database if optimization completed successfully
    # and this is still the current run
    current_state = running_optimizers.get(user, {})
    if (current_state.get("run_id") == run_id and
            current_state.get("status") == "completed"):
        await save_optimizer_result(user)


@app.post("/optimize")
async def optimize(
    user: str = Query(..., description="User identifier making the request"),
    background_tasks: BackgroundTasks = BackgroundTasks(),
    db: AsyncSession = Depends(get_db)
) -> dict[str, str]:
    """Start the optimizer in background and return immediately.

    Uses the active optimizer parameters from the database. If no optimizer
    configuration exists, creates one with default parameters (AG, time mode, n_pop=50, time=60).

    If the user already has an optimization running, it will be cancelled and a new one started.

    Parameters
    ----------
    user : str
        User identifier making the request

    Returns
    -------
    dict
        Dictionary with:
            • ``status``: "started" - optimization is running
            • ``message``: confirmation message
    """
    # Remove any existing optimization for this user
    # The old generator will continue running but won't update state anymore
    if user in running_optimizers:
        del running_optimizers[user]

    # Generate unique run ID for this optimization
    run_id = str(uuid.uuid4())

    # Ensure user has data (copy from default if needed)
    await crud.ensure_user_has_data(db, user)

    # Get optimizer parameters from database (always returns a config, creates default if needed)
    optimizer_config = await crud.get_active_optimizer(db, user)

    # Create optimizer instance
    optm = Optimizer(
        method=optimizer_config.method,
        mode=optimizer_config.mode,
        n_pop=optimizer_config.n_pop,
        n_gen=optimizer_config.n_gen,
        n_ants=optimizer_config.n_ants,
        n_iter=optimizer_config.n_iter,
        time=optimizer_config.time
    )

    # Start optimizer in background
    background_tasks.add_task(run_optimizer_background, user, optm, run_id)

    return {
        "status": "started",
        "message": "Optimization started. Use /optimize/status to check progress."
    }


@app.get("/optimize/parameters")
async def get_optimizer_parameters(
    user: str = Query(..., description="User identifier making the request"),
    db: AsyncSession = Depends(get_db)
) -> dict[str, Any]:
    """Get current optimization parameters for a specific user.

    Parameters
    ----------
    user : str
        User identifier making the request

    Returns
    -------
    dict
        Dictionary with optimization parameters:
            • ``method``: "AG" or "ACO"
            • ``mode``: "params" or "time"
            • ``n_pop``: int or None
            • ``n_gen``: int or None
            • ``n_ants``: int or None
            • ``n_iter``: int or None
            • ``time``: int or None (time in seconds)
    """
    # Get optimizer parameters from database (uses default user if user doesn't have data)
    optimizer_config = await crud.get_active_optimizer(db, user)

    return {
        "method": optimizer_config.method,
        "mode": optimizer_config.mode,
        "n_pop": optimizer_config.n_pop,
        "n_gen": optimizer_config.n_gen,
        "n_ants": optimizer_config.n_ants,
        "n_iter": optimizer_config.n_iter,
        "time": optimizer_config.time
    }


@app.get("/optimize/status")
async def get_optimize_status(
    user: str = Query(..., description="User identifier making the request")
) -> dict[str, Any]:
    """Get the current status of the optimization process.

    Parameters
    ----------
    user : str
        User identifier making the request

    Returns
    -------
    dict
        Dictionary with:
            • ``status``: "running", "completed", "error", or "not_found"
            • ``elapsed_seconds``: elapsed time in seconds (if available)
            • ``time``: total time limit in seconds (if available)
            • ``iteration``: current iteration number
            • ``max_iterations``: maximum number of iterations (if mode="params")
            • ``progress_percentage``: progress percentage (0-100)
            • ``error``: error message (if status is "error")
    """
    if user not in running_optimizers:
        return {
            "status": "not_found",
            "message": "No optimization process found for this user."
        }

    optimizer_state = running_optimizers[user]
    optm = optimizer_state["optimizer"]
    latest_update = optimizer_state.get("latest_update")
    status = optimizer_state.get("status", "running")

    if status == "error":
        return {
            "status": "error",
            "error": optimizer_state.get("error", "Unknown error")
        }

    elapsed_seconds = 0
    current_iteration = 0

    if latest_update:
        elapsed_seconds = latest_update.get("elapsed_seconds", 0)
        current_iteration = latest_update.get("iteration", 0)

    time_limit = None
    max_iterations = None
    progress_percentage = 0.0

    # Calculate progress percentage based on mode
    if optm.mode == "time":
        time_limit = optm.time
        if time_limit and time_limit > 0:
            progress_percentage = min(
                100.0, (elapsed_seconds / time_limit) * 100.0)
    elif optm.mode == "params":
        # Identify max iterations based on method
        if optm.method == "AG":
            max_iterations = optm.n_gen
        elif optm.method == "ACO":
            max_iterations = optm.n_iter

        if max_iterations and max_iterations > 0:
            progress_percentage = min(
                100.0, (current_iteration / max_iterations) * 100.0)

    return {
        "status": status,
        "elapsed_seconds": elapsed_seconds,
        "time": time_limit,
        "iteration": current_iteration,
        "max_iterations": max_iterations,
        "progress_percentage": progress_percentage
    }


@app.put("/optimize/parameters")
async def set_optimizer_parameters(
    parameters: dict[str, Any],
    user: str = Query(..., description="User identifier making the request"),
    db: AsyncSession = Depends(get_db)
) -> dict[str, str]:
    """Set optimization parameters in JSON format and save to database.

    Parameters
    ----------
    parameters : dict[str, Any]
        JSON with optimization parameters:
            • ``method``: "AG" or "ACO" (required)
            • ``mode``: "params" or "time" (required)
            • ``n_pop``: int (optional, required for AG)
            • ``n_gen``: int (optional, required for AG + params)
            • ``n_ants``: int (optional, required for ACO)
            • ``n_iter``: int (optional, required for ACO + params)
            • ``time``: int (optional, required for mode="time")
    user : str
        User identifier making the request

    Returns
    -------
    dict
        Dictionary with acknowledgment:
            • ``status``: request status
            • ``message``: confirmation message

    Raises
    ------
    HTTPException
        400 if parameters are invalid
        500 if there is an error saving
    """
    try:
        # Validate parameters by creating Optimizer instance
        # This will raise validation errors if parameters are invalid
        optm = Optimizer(**parameters)

        # Ensure user has data (copy from default if needed)
        await crud.ensure_user_has_data(db, user)

        # Save to database
        await crud.create_or_update_optimizer(
            db=db,
            user=user,
            method=optm.method,
            mode=optm.mode,
            n_pop=optm.n_pop,
            n_gen=optm.n_gen,
            n_ants=optm.n_ants,
            n_iter=optm.n_iter,
            time=optm.time
        )

        return {
            "status": "success",
            "message": "Optimization parameters saved successfully to database."
        }
    except Exception as e:
        # If it's a validation error from Pydantic, return 400
        error_msg = str(e)
        if "inválido" in error_msg or "obrigatório" in error_msg or "invalid" in error_msg.lower():
            raise HTTPException(
                status_code=400,
                detail=f"Invalid parameters: {error_msg}"
            )
        raise HTTPException(
            status_code=500,
            detail=f"Error saving optimization parameters: {error_msg}"
        )


@app.get("/ug/{ug_number}")
async def get_ug_info(ug_number: int, user: str = Query(..., description="User identifier making the request")) -> dict[str, Any]:
    """Return information for a specific UG.

    Parameters
    ----------
    ug_number : int
        UG number (1-50)
    user : str
        User identifier making the request

    Returns
    -------
    dict
        Dictionary with UG information:
            • ``ug``: UG number
            • ``cf``: power house number
            • ``portico``: gantry number
            • ``island``: island number
            • ``bladesNumber``: number of blades
            • ``voltage``: voltage in kV
            • ``localization``: location (MD, ME, LR)
            • ``producer``: manufacturer (GE, VOITH, ANDRITZ)

    Raises
    ------
    HTTPException
        404 if UG is not found
    """
    # Search for UG in UGS_INFO list
    ug_info = next(
        (ug for ug in constants.UGS_INFO if ug["ug"] == ug_number), None)

    if ug_info is None:
        raise HTTPException(
            status_code=404,
            detail=f"UG {ug_number} not found. Available UGs: 1-50"
        )

    return ug_info
